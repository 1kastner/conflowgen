from __future__ import annotations

import statistics
from collections.abc import Iterable

from conflowgen.domain_models.data_types.storage_requirement import StorageRequirement
from conflowgen.posthoc_analyses.abstract_posthoc_analysis_report import AbstractPosthocAnalysisReportWithMatplotlib
from conflowgen.posthoc_analyses.yard_capacity_analysis import YardCapacityAnalysis


class YardCapacityAnalysisReport(AbstractPosthocAnalysisReportWithMatplotlib):
    """
    This analysis report takes the data structure as generated by :class:`.YardCapacityAnalysis`
    and creates a comprehensible representation for the user, either as text or as a graph.
    """

    report_description = """
    Analyse the used capacity in the yard.
    For each hour, the containers entering and leaving the yard are checked.
    Based on this, the required yard capacity in TEU can be deduced.
    In the text version of the report, only the statistics are reported.
    In the visual version of the report, the time series is plotted.
    """

    def __init__(self):
        super().__init__()
        self.analysis = YardCapacityAnalysis()

    def get_report_as_text(self) -> str:

        used_yard_capacity_over_time = self.analysis.get_used_yard_capacity_over_time()
        if used_yard_capacity_over_time:
            used_yard_capacity_sequence = list(used_yard_capacity_over_time.values())
            maximum_used_yard_capacity = max(used_yard_capacity_sequence)
            average_used_yard_capacity = statistics.mean(used_yard_capacity_sequence)
            stddev_used_yard_capacity = statistics.stdev(used_yard_capacity_sequence)
        else:
            maximum_used_yard_capacity = average_used_yard_capacity = 0
            stddev_used_yard_capacity = -1

        used_laden_standard_container_yard_capacity_over_time = self.analysis.get_used_yard_capacity_over_time(
            storage_requirement=StorageRequirement.standard
        )
        if used_laden_standard_container_yard_capacity_over_time:
            used_laden_standard_yard_capacity_sequence = list(
                used_laden_standard_container_yard_capacity_over_time.values())
            maximum_used_laden_standard_yard_capacity = max(used_laden_standard_yard_capacity_sequence)
            average_used_laden_standard_yard_capacity = statistics.mean(used_laden_standard_yard_capacity_sequence)
            stddev_laden_standard_yard_capacity = statistics.stdev(
                used_laden_standard_yard_capacity_sequence)
        else:
            maximum_used_laden_standard_yard_capacity = average_used_laden_standard_yard_capacity = 0
            stddev_laden_standard_yard_capacity = -1

        # create string representation
        report = "\n"
        report += "                                     (reported in TEU)\n"
        report += f"maximum used yard capacity:                 {maximum_used_yard_capacity:>10.1f}\n"
        report += f"average used yard capacity:                 {average_used_yard_capacity:>10.1f}\n"
        report += f"standard deviation:                         {stddev_used_yard_capacity:>10.1f}\n"
        report += f"maximum used yard capacity (laden):         {maximum_used_laden_standard_yard_capacity:>10.1f}\n"
        report += f"average used yard capacity (laden):         {average_used_laden_standard_yard_capacity:>10.1f}\n"
        report += f"standard deviation (laden):                 {stddev_laden_standard_yard_capacity:>10.1f}\n"
        report += "(rounding errors might exist)\n"
        return report

    def get_report_as_graph(self, **kwargs) -> object:
        """
        The report as a graph is represented as a line graph using pandas.

        Returns: The matplotlib axis of the bar chart.
        """

        import pandas as pd  # pylint: disable=import-outside-toplevel
        import seaborn as sns  # pylint: disable=import-outside-toplevel
        sns.set_palette(sns.color_palette())

        storage_requirement = None
        if "storage_requirement" in kwargs:
            storage_requirement = kwargs["storage_requirement"]
            yard_capacity_over_time = self.analysis.get_used_yard_capacity_over_time(
                storage_requirement=storage_requirement
            )
        else:
            yard_capacity_over_time = self.analysis.get_used_yard_capacity_over_time()

        series = pd.Series(yard_capacity_over_time)
        ax = series.plot()
        x_label = "Used capacity (in TEU)"
        if storage_requirement is not None:
            if isinstance(storage_requirement, StorageRequirement):
                x_label += f" - storage requirement = {storage_requirement}"
            if isinstance(storage_requirement, Iterable):
                combination = " & ".join([str(element) for element in storage_requirement])
                x_label += f" - storage requirement = {combination}"
        ax.set_xlabel(x_label)
        ax.set_title("Used yard capacity analysis")
        return ax
