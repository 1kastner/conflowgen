from __future__ import annotations

from typing import Tuple, Any, Dict

import matplotlib.pyplot as plt
import matplotlib.ticker
import pandas as pd

from conflowgen.posthoc_analyses.abstract_posthoc_analysis_report import AbstractPosthocAnalysisReportWithMatplotlib
from conflowgen.posthoc_analyses.inbound_to_outbound_vehicle_capacity_utilization_analysis import \
    InboundToOutboundVehicleCapacityUtilizationAnalysis, CompleteVehicleIdentifier


class InboundToOutboundVehicleCapacityUtilizationAnalysisReport(AbstractPosthocAnalysisReportWithMatplotlib):
    """
    This analysis report takes the data structure as generated by :class:`.InboundToOutboundCapacityUtilizationAnalysis`
    and creates a comprehensible representation for the user, either as text or as a graph.
    """

    report_description = """
    Analyze the used vehicle capacity for each vehicle for the inbound and outbound journeys.
    Generally, it is striven for to reach an equilibrium - each vehicle should approximately pick up as many containers
    at the container terminal as it has delivered to.
    Great disparities between the transported capacities on the inbound and outbound journey are considered noteworthy
    but depending on the input data it might be acceptable.
    """

    maximum_length_for_readable_name = 50  # doc: Each vehicle has a name that might be a bit lengthy for text output

    def __init__(self):
        super().__init__()
        self.analysis = InboundToOutboundVehicleCapacityUtilizationAnalysis(
            transportation_buffer=self.transportation_buffer
        )

    @classmethod
    def _create_readable_name(cls, vehicle_identifier: Tuple[Any]) -> str:
        name = "-".join(str(part) for part in vehicle_identifier)
        if len(name) > cls.maximum_length_for_readable_name:
            name = name[:46] + "..."

        return name

    def get_report_as_text(self, **kwargs) -> str:
        """
        The report as a text is represented as a table suitable for logging. It uses a human-readable formatting style.

        Keyword Args:
            vehicle_type: Either ``"all"``, a single vehicle of type :class:`.ModeOfTransport` or a whole collection of
                vehicle types, e.g. passed as a :class:`list` or :class:`set`.
                For the exact interpretation of the parameter, check
                :class:`.InboundToOutboundVehicleCapacityUtilizationAnalysis`.

        Returns:
             The report in text format (possibly spanning over several lines).
        """
        capacities = self._get_capacities_depending_on_vehicle_type(kwargs)
        report = "\n"
        report += "vehicle identifier                                 "
        report += "inbound capacity (in TEU) "
        report += "outbound capacity (in TEU)"
        report += "\n"
        for vehicle_identifier, (used_inbound_capacity, used_outbound_capacity) in capacities.items():
            vehicle_name = self._create_readable_name(vehicle_identifier)
            report += f"{vehicle_name:<50} "  # align this with cls.maximum_length_for_readable_name!
            report += f"{used_inbound_capacity:>25.1f} "
            report += f"{used_outbound_capacity:>26.1f}"
            report += "\n"
        if len(capacities) == 0:
            report += "--no vehicles exist--\n"
        else:
            report += "(rounding errors might exist)\n"
        return report

    def get_report_as_graph(self, **kwargs) -> object:
        """
        The report as a graph is represented as a scatter plot using pandas.

        Keyword Args:
            plot_type: Either "absolute" or "relative".
            vehicle_type: Either ``"all"``, a single vehicle of type :class:`.ModeOfTransport` or a whole collection of
                vehicle types, e.g. passed as a :class:`list` or :class:`set`.
                For the exact interpretation of the parameter, check
                :class:`.InboundToOutboundVehicleCapacityUtilizationAnalysis`.

        Returns:
             The matplotlib axis of the scatter plot.
        """
        plot_type = kwargs.get("plot_type", "absolute")

        df = self._convert_analysis_to_df(kwargs)

        if plot_type == "absolute":
            ax = self._plot_absolute_values(df)
        elif plot_type == "relative":
            ax = self._plot_relative_values(df)
        else:
            raise Exception(f"Plot type '{plot_type}' is not supported.")

        plt.legend(
            loc='lower left',
            bbox_to_anchor=(1, 0),
            fancybox=True,
        )
        return ax

    def _plot_absolute_values(self, df: pd.DataFrame) -> matplotlib.pyplot.axis:
        ax = df.plot.scatter(x="inbound capacity (fixed)", y="used outbound capacity")
        slope = 1 + self.transportation_buffer
        ax.axline((0, 0), slope=slope, color='black', label='Maximum outbound capacity')
        ax.axline((0, 0), slope=1, color='gray', label='Equilibrium')
        ax.set_title("Inbound to outbound capacity utilization analysis (absolute)")
        ax.set_aspect('equal', adjustable='box')
        ax.grid(color='lightgray', linestyle=':', linewidth=.5)
        maximum = df[["inbound capacity (fixed)", "used outbound capacity"]].max(axis=1).max(axis=0)
        axis_limitation = maximum * 1.1  # add some white space to the top and left
        ax.set_xlim([0, axis_limitation])
        ax.set_ylim([0, axis_limitation])
        loc = matplotlib.ticker.MultipleLocator(base=25)
        ax.xaxis.set_major_locator(loc)
        return ax

    def _plot_relative_values(self, df: pd.DataFrame) -> matplotlib.pyplot.axis:
        ax = df.plot.scatter(x="inbound capacity (fixed)", y="ratio")
        ax.axline((0, (1 + self.transportation_buffer)), slope=0, color='black', label='Maximum outbound capacity')
        ax.axline((0, 1), slope=0, color='gray', label='Equilibrium')
        ax.set_title("Inbound to outbound capacity utilization analysis (relative)")
        ax.grid(color='lightgray', linestyle=':', linewidth=.5)
        return ax

    def _convert_analysis_to_df(self, kwargs: dict) -> pd.DataFrame:
        capacities = self._get_capacities_depending_on_vehicle_type(kwargs)

        rows = []
        for vehicle_identifier, (inbound_capacity, used_outbound_capacity) in capacities.items():
            vehicle_name = self._create_readable_name(vehicle_identifier)
            rows.append({
                "vehicle name": vehicle_name,
                "inbound capacity (fixed)": inbound_capacity,
                "used outbound capacity": used_outbound_capacity
            })
        df = pd.DataFrame(rows)
        df["ratio"] = df["used outbound capacity"] / df["inbound capacity (fixed)"]
        return df

    def _get_capacities_depending_on_vehicle_type(self, kwargs) -> Dict[CompleteVehicleIdentifier, Tuple[float, float]]:
        if "vehicle_type" in kwargs:
            vehicle_type = kwargs["vehicle_type"]
            capacities = self.analysis.get_inbound_and_outbound_capacity_of_each_vehicle(
                vehicle_type=vehicle_type
            )
        else:
            capacities = self.analysis.get_inbound_and_outbound_capacity_of_each_vehicle()
        return capacities
